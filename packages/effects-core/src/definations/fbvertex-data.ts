// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import type { FBVertexChannelT } from './fbvertex-channel.js';
import { FBVertexChannel } from './fbvertex-channel.js';

export class FBVertexData implements flatbuffers.IUnpackableObject<FBVertexDataT> {
  bb: flatbuffers.ByteBuffer | null = null;
  bb_pos = 0;
  __init (i: number, bb: flatbuffers.ByteBuffer): FBVertexData {
    this.bb_pos = i;
    this.bb = bb;

    return this;
  }

  static getRootAsFBVertexData (bb: flatbuffers.ByteBuffer, obj?: FBVertexData): FBVertexData {
    return (obj || new FBVertexData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsFBVertexData (bb: flatbuffers.ByteBuffer, obj?: FBVertexData): FBVertexData {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);

    return (obj || new FBVertexData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  vertexCount (): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);

    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  channels (index: number, obj?: FBVertexChannel): FBVertexChannel | null {
    const offset = this.bb!.__offset(this.bb_pos, 6);

    return offset ? (obj || new FBVertexChannel()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
  }

  channelsLength (): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);

    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  static startFBVertexData (builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addVertexCount (builder: flatbuffers.Builder, vertexCount: number) {
    builder.addFieldInt32(0, vertexCount, 0);
  }

  static addChannels (builder: flatbuffers.Builder, channelsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, channelsOffset, 0);
  }

  static createChannelsVector (builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }

    return builder.endVector();
  }

  static startChannelsVector (builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endFBVertexData (builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();

    return offset;
  }

  static createFBVertexData (builder: flatbuffers.Builder, vertexCount: number, channelsOffset: flatbuffers.Offset): flatbuffers.Offset {
    FBVertexData.startFBVertexData(builder);
    FBVertexData.addVertexCount(builder, vertexCount);
    FBVertexData.addChannels(builder, channelsOffset);

    return FBVertexData.endFBVertexData(builder);
  }

  unpack (): FBVertexDataT {
    return new FBVertexDataT(
      this.vertexCount(),
      this.bb!.createObjList<FBVertexChannel, FBVertexChannelT>(this.channels.bind(this), this.channelsLength())
    );
  }

  unpackTo (_o: FBVertexDataT): void {
    _o.vertexCount = this.vertexCount();
    _o.channels = this.bb!.createObjList<FBVertexChannel, FBVertexChannelT>(this.channels.bind(this), this.channelsLength());
  }
}

export class FBVertexDataT implements flatbuffers.IGeneratedObject {
  constructor (
    public vertexCount: number = 0,
    public channels: (FBVertexChannelT)[] = []
  ) {}

  pack (builder: flatbuffers.Builder): flatbuffers.Offset {
    const channels = FBVertexData.createChannelsVector(builder, builder.createObjectOffsetList(this.channels));

    return FBVertexData.createFBVertexData(builder,
      this.vertexCount,
      channels
    );
  }
}

第一阶段：监听状态
纹理从右往左移动200单位
总时长3.4秒
0~0.6秒：渐显（透明度0->1）
2.4~3.4秒：渐隐（透明度1->0）
期间监听音量
如果音量在2.4s渐隐开始时超过阈值→在3.4s时触发第二阶段
如果音量在2.4s时没有超过阈值->在2.4s出发循环第一次循环继续消隐并且和第二次循环的渐显进行透明度混合，以此类推

第二阶段：音乐输入阶段
1号纹理继续从右向左移动400单位，2.4s
0~0.4s渐显（透明度0->1）
1.9~2.4s渐隐（透明度1->0）
0.5s的时候，在最右边生成2号纹理，也做同样的移动（2.4s, 400单位）

0.5~1s：2号纹理渐显（透明度0->1）
1.9~2.4s: 2号纹理渐隐（透明度1->0）
两个纹理透明度混合

在1.9s时（A与B都处于消隐期）时检测音量

如果音量 > threshold，立刻再次进入第二阶段、
循环第二阶段：新的纹理从右到左滑入，透明度混合显示，老的继续消失，新的继续渐显
如果音量 ≤ threshold，在消隐过程中完成后结束第二阶段流程
如果刚进入消隐，等消隐结束
渐显期，则等待渐显完成直接进入消隐
如果在全显，则直接进入消隐

实现参考
以下是基于你描述的音频监听/触发逻辑实现：TS部分负责音频状态机驱动、纹理淡入淡出与切换，Shader部分负责波形渲染与透明度采样，支持多纹理Alpha混合。整体方案兼容WebGL1，结构清晰。

1. TypeScript 音频状态与控制部分
先定义状态枚举，监听音量并根据时序/阈值驱动第一、二阶段流程，控制两张（或多张）纹理的运动与透明度混合。
// 阶段定义
enum MainStage { Listening, Input, Stop }
enum TexFadeStage { Hidden, FadingIn, Showing, FadingOut }

interface TexState {
  x: number;                     // 横向位置
  stage: TexFadeStage;           // 当前透明阶段
  alpha: number;                 // 当前透明度
  time: number;                  // 当前阶段内时间
  life: number;                  // 累计生存时间
  startedAt: number;             // 全局计时起始
  duration: number;              // 整体存在时长
}

class TextureController {
  textures: TexState[] = [];
  mainStage: MainStage = MainStage.Listening;
  pendingLoop: boolean = false;
  timer: number = 0;
  // 监听判据
  volumeThreshold: number = 0.3;

  // 第一阶段参数
  listeningDuration = 3.4;
  movingDistance = 200;
  fadeInMs = 0.6;
  fadeOutStart = 2.4;
  fadeOutEnd = 3.4;

  // 第二阶段参数
  inputDuration = 2.4;
  inputDistance = 400;
  textureInterval = 0.5; // 第二张纹理的延时
  fadeInA = 0.4;
  fadeOutA = 0.5; // 1.9~2.4s
  fadeInB = 0.5; // 0.5~1s
  fadeOutB = 0.5; // 1.9~2.4s

  onStage: (stage: MainStage) => void = () => {};
  onUpdate: (texs: TexState[]) => void = () => {};

  constructor() {}
  resetToListening(now: number) {
    this.mainStage = MainStage.Listening;
    this.pendingLoop = false;
    this.timer = 0;
    this.textures = [{
      x: 0,
      stage: TexFadeStage.FadingIn,
      alpha: 0,
      time: 0,
      life: 0,
      startedAt: now,
      duration: this.listeningDuration,
    }];
    this.onStage(MainStage.Listening);
  }
  triggerInputStage(now: number) {
    this.mainStage = MainStage.Input;
    this.pendingLoop = false;
    this.timer = 0;
    this.textures = [{
      x: 0,
      stage: TexFadeStage.FadingIn,
      alpha: 0,
      time: 0,
      life: 0,
      startedAt: now,
      duration: this.inputDuration,
    }];
    this.onStage(MainStage.Input);
  }
  stop() {
    this.mainStage = MainStage.Stop;
    this.textures = [];
    this.onStage(MainStage.Stop);
  }

  update(delta: number, volume: number, now: number) {
    this.timer += delta;

    // 第一阶段：监听
    if (this.mainStage === MainStage.Listening) {
      const t = this.timer;
      let tex = this.textures[0];
      tex.life += delta;
      tex.x = (t / this.listeningDuration) * (-this.movingDistance);

      // 0~0.6渐显
      if (t <= this.fadeInMs) {
        tex.stage = TexFadeStage.FadingIn;
        tex.alpha = Math.min(1, t / this.fadeInMs);
      }
      // 0.6~2.4全显
      else if (t > this.fadeInMs && t < this.fadeOutStart) {
        tex.stage = TexFadeStage.Showing;
        tex.alpha = 1;
      }
      // 2.4~3.4渐隐
      else if (t >= this.fadeOutStart && t <= this.fadeOutEnd) {
        tex.stage = TexFadeStage.FadingOut;
        tex.alpha = 1 - (t - this.fadeOutStart) / (this.fadeOutEnd - this.fadeOutStart);
      }
      // 超时
      else if (t > this.fadeOutEnd) {
        tex.alpha = 0;
      }

      // 2.4s音量判定
      if (t >= this.fadeOutStart && t < this.fadeOutEnd && !this.pendingLoop) {
        if (volume > this.volumeThreshold) {
          // 3.4s时进入第二阶段
          this.pendingLoop = true;
        } else {
          // 消隐且循环
          this.pendingLoop = false;
        }
      }

      // 消隐期结束，决定流转
      if (t >= this.fadeOutEnd) {
        if (this.pendingLoop) {
          this.triggerInputStage(now);
        } else {
          // 接续下一轮Listening叠加fade（循环/混合机制如下）
          this.resetToListening(now);
        }
      }
    }
    // 第二阶段：输入/循环阶段（A, B纹理混合）
    else if (this.mainStage === MainStage.Input) {
      // A: 第一张
      let tA = this.timer;
      let texA = this.textures[0];
      texA.life = tA;
      texA.x = (tA / this.inputDuration) * (-this.inputDistance);

      if (tA < this.fadeInA) {
        texA.stage = TexFadeStage.FadingIn;
        texA.alpha = tA / this.fadeInA;
      } else if (tA < 1.9) {
        texA.stage = TexFadeStage.Showing;
        texA.alpha = 1;
      } else if (tA < this.inputDuration) {
        texA.stage = TexFadeStage.FadingOut;
        texA.alpha = 1 - (tA - 1.9) / (this.inputDuration - 1.9);
      } else {
        texA.stage = TexFadeStage.Hidden;
        texA.alpha = 0;
      }

      // B: 第二张，0.5s后补发
      if (!this.textures[1] && this.timer > this.textureInterval) {
        this.textures[1] = {
          x: 0,
          stage: TexFadeStage.FadingIn,
          alpha: 0,
          time: 0,
          life: 0,
          startedAt: now,
          duration: this.inputDuration,
        };
      }

      // 更新B
      let texB = this.textures[1];
      if (texB) {
        let tB = tA - this.textureInterval;
        texB.life = tB;
        texB.x = (tB / this.inputDuration) * (-this.inputDistance);
        if (tB < 0) {
          texB.alpha = 0;
        } else if (tB < this.fadeInB) {
          texB.stage = TexFadeStage.FadingIn;
          texB.alpha = tB / this.fadeInB;
        } else if (tB < 1.9 - this.textureInterval) {
          texB.stage = TexFadeStage.Showing;
          texB.alpha = 1;
        } else if (tB < this.inputDuration) {
          texB.stage = TexFadeStage.FadingOut;
          texB.alpha = 1 - (tB - (1.9 - this.textureInterval)) / (this.inputDuration - (1.9 - this.textureInterval));
        } else {
          texB.stage = TexFadeStage.Hidden;
          texB.alpha = 0;
        }
      }

      // 1.9s时检测音量
      if (tA >= 1.9 && !this.pendingLoop) {
        if (volume > this.volumeThreshold) {
          // 立即进入第二阶段（第三轮）
          this.pendingLoop = true;
        }
      }

      // 正常消隐过程结束后
      if (tA >= this.inputDuration) {
        if (this.pendingLoop) { // 新起一轮
          this.triggerInputStage(now);
        } else {
          this.stop();
        }
      }
    }

    this.onUpdate(this.textures);
  }
}
在渲染主循环里，根据TextureController的输出动态设置每张纹理的shader uniform：
let controller = new TextureController();
let lastTime = performance.now();
function renderLoop(now: number, volume: number) {
  let delta = (now - lastTime) / 1000;
  lastTime = now;
  controller.update(delta, volume, now);

  controller.textures.forEach((tex, i) => {
    // 根据 tex.x, tex.alpha 设uniform: offset/alpha等
    // 示例
    material[i].setFloat('_TextureX', tex.x);
    material[i].setFloat('_Alpha', tex.alpha);
    // ...
  });
  requestAnimationFrame(now => renderLoop(now, getAudioVolume()));
}
配合每个纹理的material传给shader对应的uniform。如果一个shader同时支持两张纹理混合，可以设第二份参数（_Alpha2/_TextureX2等）；否则分两draw call实现混合。
音量来自getAudioVolume()（你可用已集成的AudioStateMachine输出）。

2. Shader 支持动态横移及多纹理透明度混合
核心点是**（1）支持横向偏移，（2）支持Alpha淡入淡出，（3）支持叠加混合**。
假设同一shader渲染两张图，通过两个uniform（_OffsetA, _OffsetB）和(_AlphaA, _AlphaB)传入。
precision highp float;
varying vec2 uv;
uniform float _OffsetA, _OffsetB;
uniform float _AlphaA, _AlphaB;
uniform sampler2D uTexA, uTexB;
// ... 其他波形参数

void main() {
  vec2 uvA = uv;
  uvA.x += _OffsetA;
  vec2 uvB = uv;
  uvB.x += _OffsetB; 
  // 支持超出边界采样自动透明
  float maskA = step(0.0, uvA.x) * step(uvA.x, 1.0);
  float maskB = step(0.0, uvB.x) * step(uvB.x, 1.0);

  vec4 colorA = texture2D(uTexA, uvA) * _AlphaA * maskA;
  vec4 colorB = texture2D(uTexB, uvB) * _AlphaB * maskB;

  // 混合
  gl_FragColor = colorA + colorB * (1.0 - colorA.a);
  // 你也可以用加法等其他方式混合
}
更通用处理可进一步抽象成数组uniform循环。
如果只渲染一张纹理（无第二阶段）可只赋值A相应的参数。

3. 关键点小结
● TS端精确驱动阶段、每张纹理的位置和透明，通过uniform同步到Shader。
● Shader通过偏移和Alpha通道实现律动横移+消隐，支持两张图叠加混合。
● 可用你的UI面板实时调参数。
● 音量检测阈值由controller.volumeThreshold控制，记得参数化。
● onUpdate钩子可用于同步动画状态到渲染和UI。

你可以把controller和render部分集成到你现有的音频状态管理逻辑内。
如需更复杂的多轮叠加，也可动态扩展controller.textures数组、shader支持更多层透明累加。

如需完整集成demo和具体接口封装，请补充所用素材和UI/引擎架构。
如需任意一侧（TS/Shader/集成）细致代码片段解释可再补充。


现在任务需要修改的
https://yuque.antfin.com/houzhenni.hzn/kb/ak4ba3kmntn5ymm1?singleDoc#沟通问题

一、阶段一：只有蓝光的部分
整体图形的边缘可以再模糊一些，目前看起来形状还是较为明显

1.抄一个ae原文件的第一阶段

二、阶段二：蓝绿光
1. 蓝色光和绿色光，在左侧起始的部分，顶部的部分过度比较僵硬，边缘过于清晰，也是希望更加模糊，参考绿色的部分
    
初步感觉应该是ae原版本有一个框的高斯模糊效果，为准备给弄到ge里面做一个实现参考

2. 来回交替时，会有左右晃动的视感，最好整体都遵循 蓝绿色光 向左侧移动。

 这个是时间轴问题，可能和ae时间轴没有完全对齐（比如ae的纹理的初始位置不能完全转换到shader uv到问题），导致有差异。
所以我需要给初始位置暴露出来可以快速调整

我查看了ae，文件大概原因是第一波蓝绿几乎同时消失，消失的同时第二波蓝已经开出现了，并且等第一波蓝绿消失，第二波蓝已经到了比较前面的一个位置了，这样视觉上不会又左右移动的感觉

三、动态语音接入的样式规则
Max值：可以给个参考单位
高度规则&图片 待补充

Mix值：可以给个参考单位
高度规则&图片 待补充

将扰动和高低的参数暴露出来，并且告诉他们含义，我到设计工位和他们一起调整获取一个参考值
然后将大部分参数都找到默认值，然后将关键参数拿出来参数化使用
还包括问题二的时间轴对齐的问题



第一阶段
蓝色光
0:00:01:00 透明度从0开始变到100
y从1627.164变到1560.164 (画布1624)

0:00:01:15 透明度到100 ，y到了1560.164

0:00:03:09 x从534.3934到了442.3934，y从1560.164到了1578.164，
然后透明度准备从100到0

x和y准备从442.3934到259.3934和1578.164到1601.164

0:00:04:10 透明度从100到了0

0:00:04:11到达x259.3934和y1601.164


绿色光
0:00:01:12 y 准备从1698到 1644 透明度准备从0到100

0:00:02:07 y到达1644，透明度到达100

0:00:03:09透明度准备从 100到0

0:00:03:21x从204到了-1，y从1644到了1732

0:00:04:11透明度从100到了0

0:00:03:18进入第二阶段，第二阶段开始